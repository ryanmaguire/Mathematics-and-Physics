%-----------------------------------LICENSE------------------------------------%
%   This file is part of Mathematics-and-Physics.                              %
%                                                                              %
%   Mathematics-and-Physics is free software: you can redistribute it and/or   %
%   modify it under the terms of the GNU General Public License as             %
%   published by the Free Software Foundation, either version 3 of the         %
%   License, or (at your option) any later version.                            %
%                                                                              %
%   Mathematics-and-Physics is distributed in the hope that it will be useful, %
%   but WITHOUT ANY WARRANTY; without even the implied warranty of             %
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              %
%   GNU General Public License for more details.                               %
%                                                                              %
%   You should have received a copy of the GNU General Public License along    %
%   with Mathematics-and-Physics.  If not, see <https://www.gnu.org/licenses/>.%
%------------------------------------------------------------------------------%
%       Author: Ryan Maguire, Dartmouth College                                %
%       Date:   2021/11/16                                                     %
%------------------------------------------------------------------------------%
\documentclass{article}

% Needed for figures.
\usepackage{graphicx}

% Needed for mathbb font style.
\usepackage{amssymb}

% Tools for creating the theorem environment.
\usepackage{amsthm}

% The align environment is here.
\usepackage{amsmath}

% Library of colors, used here for displaying code.
\usepackage{xcolor}

% Used for displaying code in a LaTeX document.
\usepackage{listings}

% Used for correct hyperlinks with figures.
\usepackage[font={scriptsize}, hypcap=true, labelsep=colon]{caption}

% Hyperlinks for labels.
\usepackage{hyperref}

% Background color for code.
\definecolor{background}{rgb}{0.9, 0.9, 0.9}

% Display style used for the C programming language in this document.
\lstdefinestyle{CStyle}{
    backgroundcolor=\color{background},
    commentstyle=\color{gray},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{red},
    stringstyle=\color{orange},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C
}

% Display style for hyperlinks.
\hypersetup{
    colorlinks=true,
    linkcolor=blue
}

% Create a theorem environment, similar to most textbooks.
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}

% No indent and no paragraph skip.
\setlength{\parindent}{0em}
\setlength{\parskip}{0em}

% Title page information.
\title{An Iterative Algorithm for the Jones' Polynomial via Extended Gauss Code}
\author{Ryan Maguire\hspace{2em}Vladimir Chernov\hspace{2em}Peter Doyle}
\date{Fall 2021}

\begin{document}
    \maketitle
    \tableofcontents
    \begin{abstract}
        \noindent
        An iterative algorithm for computing the Jones' polynomial of a knot
        is described and an analysis of the computational complexity is given.
        Generalized conjectures about the Jones' polynomial are shown to be
        false by counterexamples, and a conjecture generalizing Kronheimer and
        Mrowka's result on the unknot is made, with supporting numerical
        evidence.
    \end{abstract}
    \section{Extended Gauss Code}
        Given a knot diagram, it is reasonable for a mathematician to wish to
        describe the figure with finite data in such a way that a computer can
        understand and perform computations. This is achieved via Gauss code.
        Orient the knot, label the crossings, and choose a starting point.
        Walk along the diagram, following the orientation, and record the
        crossings. That is, write down the crossing number, and whether the
        the path goes under or over the crossing with a $U$ or $O$,
        respectively. This is illustrated via example for the right-handed
        trefoil knot in Fig.~\ref{fig:right_handed_trefoil_gauss_code}.
        \begin{figure}
            \centering
            \includegraphics{%
                ../images/trefoil_knot_oriented_with_gauss_code.pdf%
            }
            \caption{Gauss Code for the Right Handed Trefoil}
            \label{fig:right_handed_trefoil_gauss_code}
        \end{figure}
        Gauss code is not unique to a knot diagram since the code is dependent
        on the choice of starting point. This causes two different issues.
        First, when trying to determine if two knots are the same, we must
        check if one Gauss code is a cyclic permutation of another. Secondly,
        and more importantly, this version of Gauss code cannot distinguish
        between a knot and its mirror. If we take the left-handed trefoil,
        give it a similar orientation as before, but choose a different
        starting point, we end up with
        Fig.~\ref{fig:left_handed_trefoil_gauss_code}. The resulting Gauss code
        is the same as the Gauss code we get for the right-handed trefoil.
        These are different knots since they have different Jones' polynomials,
        meaning Gauss code cannot distinguish mirrors.
        \begin{figure}
            \centering
            \includegraphics{%
                ../images/trefoil_knot_mirror_oriented_with_gauss_code.pdf%
            }
            \caption{Gauss Code for the Left Handed Trefoil}
            \label{fig:left_handed_trefoil_gauss_code}
        \end{figure}
        The solution is to \textit{sign} the crossings. Given an oriented knot,
        we label a crossing positive or negative depending on which strand is
        over and which is under. This is shown in Fig.~\ref{fig:crossing_signs}.
        \begin{figure}
            \centering
            \includegraphics{../images/crossing_signs.pdf}
            \caption{Gauss Code for the Left Handed Trefoil}
            \label{fig:crossing_signs}
        \end{figure}
        By keeping track of the sign we get extended Gauss code
        (also called signed Gauss code).
        \begin{figure}
            \centering
            \includegraphics{%
                ../images/trefoil_knot_oriented_with_extended_gauss_code.pdf%
            }
            \caption{Extended Gauss Code for the Right Handed Trefoil}
            \label{fig:right_hand_trefoil_extended_gauss}
        \end{figure}
        Note the orientation does not matter. If we reverse the orientation,
        the signs are still preserved. Examine Fig.~\ref{fig:crossing_signs} to
        convince yourself of this.
        \par\hfill\par
        Computationally, Extended Gauss code is a finite sequence of ordered
        triples. The length of the sequence is $2N$ where $N$ is the number of
        crossings in the diagram, and the ordered triples are of the form
        $(t,n,s)$ where $t\in\{O,U\}$, $s\in\{+1,-1\}$, and
        $0\leq{n}\leq{N-1}$ ($t$ for \textit{type}, $s$ for \textit{sign}, and
        $n$ for indexing). One could represent this in the C programming
        language as follows.
        \begin{lstlisting}[style=CStyle, gobble=12]
            enum crossing_sign {negative_crossing, positive_crossing};
            enum crossing_type {under_crossing, over_crossing};

            struct knot {
                unsigned int number_of_crossings;
                enum crossing_sign *sign;
                enum crossing_type *type;
                unsigned int *crossing_number;
            };
        \end{lstlisting}
        The pointers to the arrays \texttt{sign}, \texttt{type}, and
        \texttt{crossing\_number} each having 2 times
        \texttt{number\_of\_crossings} many elements.
        Similar definitions could easily be given with classes using the
        Python programming language. Regardless of preference, we now have a
        means of representing a knot in a computer.
    \section{Virtual Knots}
        Not all finite sequences of length $2N$ will be valid Gauss code. For
        the code to be valid every integer $0\leq{n}\leq{N-1}$ must occur
        exactly twice, once with $t=O$ and once with $t=U$, and the sign
        $s$ must be the same for both crossings. Consider the following Gauss
        code:
        \begin{equation}
            O0+O1+U0+U1+
        \end{equation}
        It satisfies the above criterion.
        The code tells us we have a two crossing knot. A quick look through any
        table of knots tells us the smallest number of crossings a non-trivial
        knot can have is 3 (the left and right trefoils). The
        Reidemeister moves can translate to operations on extended Gauss code,
        but you'll find they're of no help here. Let's try to draw it
        (Fig.~\ref{fig:chain_link_fence_knot}).
        \begin{figure}
            \centering
            \includegraphics{../images/chain_link_fence_knot_virtual.pdf}
            \caption{The Chain Link Fence Knot}
            \label{fig:chain_link_fence_knot}
        \end{figure}
        To do this on a piece of paper requires us to pretend one crossing is
        fake, or \textit{virtual}. Graph theory tells us we really want to draw
        this on a higher genus surface. Using the torus $\mathbb{T}^{2}$ we can
        draw this knot without virtual crossings
        (Fig.~\ref{fig:chain_link_fence_knot_on_torus}). This will be called
        the \textit{chain-link-fence} knot. The name makes sense if we draw it
        on the flat torus (Fig.~\ref{fig:chain_link_fence_knot_on_flat_torus}).
        \begin{figure}
            \centering
            \includegraphics{../images/chain_link_fence_knot_on_torus.pdf}
            \caption{The Chain Link Fence Knot on a Torus}
            \label{fig:chain_link_fence_knot_on_torus}
        \end{figure}
        \begin{figure}
            \centering
            \includegraphics{../images/chain_link_fence_knot_on_flat_torus.pdf}
            \caption{The Chain Link Fence Knot on a Flat Torus}
            \label{fig:chain_link_fence_knot_on_flat_torus}
        \end{figure}
        Lifting this drawing to the universal cover, we see a chain-link fence
        (Fig.~\ref{fig:chain_link_fence_knot_on_flat_torus_universal_cover}).
        Such objects are called \textit{virtual knots}, knots that can be
        embedded into some 3-manifold of the form $M\times\mathbb{R}$ where
        $M$ is a smooth surface. Given the Gauss code of a virtual knot, if your
        drawing requires you to have $m$ virtual crossings, you could embed the
        knot diagram into the compact surface $M$ of genus $m$. At every virtual
        crossing you add a handle, removing the crossing. The result is an
        embedding of the diagram onto $M$, meaning the virtual knot could be
        embedded into $M\times\mathbb{R}$. This idea is a
        mimicry of the proof that every graph can be embedded onto some surface.
        A classical knot is a virtual knot that can be embedded into
        $\mathbb{S}^{2}\times\mathbb{R}$. The chain-link-fence knot is the
        simplest non-trivial virtual knot. There are no virtual knots with one
        crossing (but there are virtual \textit{links} with one crossing). This
        is useful for test computations.
        \begin{figure}
            \centering
            \resizebox{\textwidth}{!}{%
                \includegraphics{%
                    ../images/chain_link_fence_knot_on_flat_torus_universal_cover.pdf%
                }%
            }
            \caption{Lift of the Chain Link Fence Knot to $\mathbb{R}^{2}$}
            \label{fig:chain_link_fence_knot_on_flat_torus_universal_cover}
        \end{figure}
    \section{Resolving a Crossing}
        The Kauffman bracket polynomial is an invariant for
        \textit{framed links}. It is not a link invariant since the polynomial
        is not preserved by Reidemeister I moves (though this can be salvaged
        by a proper normalization, resulting in the Jones' polynomial). The
        definition we'll give in the next section is similar to the
        description provided in \cite{barnatan2002khovanov}. It is recursive
        and requires us to \textit{resolve crossings}. Resolving a crossing
        equates to removing it. There are two ways to do this.
        Given an unoriented knot diagram, we rotate our heads until
        the over crossing travels from the top left to the bottom right. The
        0 and 1 resolution of the crossing are given in
        Fig.~\ref{fig:resolving_crossing}.
        \begin{figure}
            \centering
            \includegraphics{../images/resolving_crossings.pdf}
            \caption{Resolving a Crossing}
            \label{fig:resolving_crossing}
        \end{figure}
        Given the Gauss code of a knot diagram with $N$ crossings, and a number
        $0\leq{n}\leq{2}^{N}-1$, there is a unique resolution of all of the
        crossings corresponding to $n$. Write $n$ in binary. The value of the
        $k^{th}$ bit in the binary representation of $n$ corresponds to how the
        $k^{th}$ crossing is smoothed. Examine the right-handed trefoil with its
        standard knot diagram (Fig.~\ref{fig:right_handed_trefoil_gauss_code}).
        There are 3 crossings, so $2^{3}=8$ possible resolutions. The diagram
        in Fig.~\ref{fig:trefoil_knot_cube_of_resolutions} is called the
        \textit{cube of resolutions} for the right-handed
        trefoil. This language is slightly misleading since the cube of
        resolutions is dependent on the knot diagram, so it is better to say
        this is the cube of resolutions for the \textit{standard} diagram of
        the right-handed trefoil. The image gets complicated quickly since the
        size of the cube is exponential in the number of crossings. The cube of
        resolutions for the figure-eight knot is shown in
        Fig.~\ref{fig:figure_eight_knot_cube_of_resolutions}.
        \begin{figure}
            \centering
            \includegraphics{../images/trefoil_knot_cube_of_resolutions.pdf}
            \caption{Cube of Resolutions for the Left-Handed Trefoil}
            \label{fig:trefoil_knot_cube_of_resolutions}
        \end{figure}
        \begin{figure}
            \centering
            \resizebox{\textwidth}{!}{%
                \includegraphics{%
                    ../images/figure_eight_knot_cube_of_resolutions.pdf%
                }%
            }
            \caption{Cube of Resolutions for the Figure-Eight}
            \label{fig:figure_eight_knot_cube_of_resolutions}
        \end{figure}
        Connecting the appropriate images with arrows results in a tesseract.
        For neatness, this has been omitted.
    \section{The Kauffman Bracket}
        The Kauffman bracket polynomial of a link $L$ is defined recursively
        in terms of smoothings of a link diagram. The definition is:
        \begin{align}
            \langle\emptyset\rangle&=1\\
            \langle{L\sqcup\mathbb{S}^{1}}\rangle&=(q+q^{-1})\langle{L}\rangle\\
            \langle{L}\rangle&=
                \langle{L_{n,0}}\rangle-q\langle{L_{n,1}}\rangle
        \end{align}
        where $L_{n,0}$ and $L_{n,1}$ are the links obtained from the
        0 and 1 smoothings of $L$ at the $n^{th}$ crossing, respectively. The
        notation $L\sqcup\mathbb{S}^{1}$ means the disjoint union of
        $L$ with an unknot. Hence the Kaufmann bracket of the
        unknot is $q+q^{-1}$.
        \par\hfill\par
        The third equation reduces an $N$ crossing link to two $N-1$ crossing
        links. If we continue this recursive step we'll end up with
        $2^{N}$ completely resolved links, each being the disjoint union of
        circles. Applying the first and second equations, we can inductively
        prove the following formula for the Kauffman bracket:
        \begin{equation}
            \langle{L}\rangle=\sum_{n=0}^{2^{N}-1}
                (-q)^{w(n)}(q+q^{-1})^{c(n)}
        \end{equation}
        Here, $w(n)$ is the Hamming weight of $n$, the number of 1's
        that occur in the binary expansion of $n$. Recalling that an integer
        $0\leq{n}\leq{2}^{N}-1$ represents a complete smoothing of a knot,
        $c(n)$ is the number of circles that result from the $n$ smoothing.
        The Hamming weight is a well studied function and efficient methods of
        computing it are known, including constant-time algorithms if one
        restricts their attention to fixed-width integers
        (usually 32 or 64 bit). A general and portable algorithm can be done in
        $\log(n)$ time as follows.
        \begin{lstlisting}[style=CStyle, gobble=12]
            static unsigned int hamming_weight(unsigned int val)
            {
                unsigned int result = 0U;

                while(val != 0U)
                {
                    result += val & 1U;
                    val = val >> 1U;
                }

                return result;
            }
        \end{lstlisting}
        The code \texttt{result += val \& 1U} may need explanation.
        \texttt{val \& 1U} performs a bitwise \texttt{AND} with \texttt{val} and
        1. Since the binary representation of 1 is zero in all slots except the
        zeroth bit, \texttt{val \& 1U} is simply checking the zeroth bit of
        \texttt{val}. We add this value to \texttt{result}, ultimately giving
        us the Hamming weight. The code \texttt{val = val >> 1U} takes val and
        shifts it 1 bit to the right. So, if we had $111_{2}$ and shift it to
        the right, we'd end up with $011_{2}$. Because of this, after
        \texttt{log(val)} steps \texttt{val} would be zero, exiting the
        while-loop.
        \par\hfill\par
        For the Kauffman bracket this is function is used with inputs of size
        $2^{N}-1$, where $N$ is the number of crossings, so the worst-case
        time complexity at this step is $O(N)$. For example, considering the
        resolution of the right-handed trefoil
        in Fig.~\ref{fig:right_hand_trefoil_extended_gauss} corresponding to
        $7=111_{2}$, the loop will end after 3 steps, one step for each
        crossing. The $000_{2}$ resolution exits immediately.
        \par\hfill\par
        With the Hamming weight settled, the remaining information needed to
        compute the Kauffman bracket is the number of circles that result from
        the $n^{th}$ smoothing ($0\leq{n}\leq{2}^{N}-1$). This paper gives a
        simple algorithm using extended Gauss code. The code outlined works for
        knots, but simple extensions could be made for links. In particular, the
        algorithm works for \textit{virtual knots} and there is no restriction
        to the classical setting.
    \section{The Circle Counting Algorithm}
        The visual for the algorithm goes as follows. Given a knot, we thicken
        it into a framed knot (Fig.~\ref{fig:trefoil_knot_framed_001}). Every
        crossing becomes a four-way intersection
        (Fig.~\ref{fig:thickened_crossings}), and the idea is to loop
        over then $4N$ roads in this thickened knot, $N$ being the number of
        crossings. We first examine the negative crossing. The 0 and 1
        smoothings are shown in
        Fig.~\ref{fig:thickened_negative_crossing_smoothings}. Suppose we start
        on the bottom-left road of the 0-smoothing and walk towards the
        crossing. The smoothing in the visual equates to a road block, the thick
        black line we are unable to pass through. We are thus forced to go down
        the bottom-right road. The arrow for this road is going the wrong way,
        pointing towards the crossing and we are moving away from it.
        To preserve orientation we must walk backwards. This
        translates as follows for extended Gauss code. Approaching a negative
        crossing from the bottom left road means we have approached $Un-$ in
        the code reading left-to-right, $n$ being the crossing number. The
        road block tells us to go down the bottom right road, but in reverse.
        That is, look for $On-$ in the code and then go
        to the \textit{previous} entry in the code.
        This is equivalent to walking backwards. We end up at a new crossing.
        We now know the rule for approaching a crossing from the bottom left
        road for a negative crossing given the 0-smoothing. In total there are
        16 possible cases: Is the sign $+1$ or $-1$, is the type $U$ or $O$, is
        the smoothing $0$ or $1$, is the direction forwards or backwards. The
        visuals for these 16 combinations are shown in
        Fig.~\ref{fig:thickened_negative_crossing_smoothings} and
        Fig.~\ref{fig:thickened_positive_crossing_smoothings}.
        \par\hfill\par
        \begin{figure}
            \centering
            \includegraphics{../images/trefoil_knot_framed_001.pdf}
            \caption{Framed Left-Handed Trefoil}
            \label{fig:trefoil_knot_framed_001}
        \end{figure}
        \begin{figure}
            \centering
            \includegraphics{../images/thickened_crossings.pdf}
            \caption{Signed Crossings in a Framed Knot}
            \label{fig:thickened_crossings}
        \end{figure}
        \begin{figure}
            \centering
            \includegraphics{../images/thickened_negative_crossing_smoothings.pdf}
            \caption{Smoothing a Negative Crossing in a Framed Knot}
            \label{fig:thickened_negative_crossing_smoothings}
        \end{figure}
        \begin{figure}
            \centering
            \includegraphics{../images/thickened_positive_crossing_smoothings.pdf}
            \caption{Smoothing a Positive Crossing in a Framed Knot}
            \label{fig:thickened_positive_crossing_smoothings}
        \end{figure}
        Jumping from the over-crossing to the under-crossing, and vice-verse,
        as is needed in the algorithm is made easier if we have an array
        \texttt{ind} such that \texttt{ind[n]} is an ordered pair whose
        zeroth entry is the index of the under-crossing for the $n^{th}$
        crossing, and first entry is the index of the over-crossing. It is then
        useful to describe a \texttt{struct} for this ordered pair, and an
        algorithm to obtain this array.
        \begin{lstlisting}[style=CStyle, gobble=12]
            struct CrossingIndices {
                unsigned int under;
                unsigned int over;
            };

            static struct CrossingIndices *get_indices(struct knot *K)
            {
                unsigned int n;
                struct CrossingIndices *ind;

                if (!K)
                    return NULL;

                if (K->number_of_crossings == 0U)
                    return NULL;

                ind = malloc(sizeof(*ind)*K->number_of_crossings);

                if (!ind)
                    return NULL;

                for (n = 0U; n < 2U * K->number_of_crossings; ++n)
                {
                    if (K->type[n] == over_crossing)
                        ind[K->crossing_number[n]].over = n;
                    else
                         ind[K->crossing_number[n]].under = n;
                }

                return ind;
            }
        \end{lstlisting}
        The error checks are for good programming practice: Check if your
        input pointer is \texttt{NULL}, don't assume \texttt{malloc} was
        successful, and don't pass zero to \texttt{malloc}. The actual algorithm
        is contained in the for loop. We loop over the Gauss code, ask which
        crossing number we have, and then add this index to our array. The
        loop requires $2N$ steps, $N$ being the number of crossings, so this
        step is $O(N)$. Unlike the Hamming weight and the number of circles
        from a resolution, this index-finding algorithm is only needed once. We
        execute the algorithm at the start and then store the result in
        memory.
        \par\hfill\par
        Because of the 16 possibilies, the full algorithm is lengthy and given
        in the appendix of this paper. To determine where you go next, given
        where you're coming from, you simply examine
        Fig.~\ref{fig:thickened_negative_crossing_smoothings} and
        Fig.~\ref{fig:thickened_positive_crossing_smoothings}.
    \newpage
    \bibliographystyle{plain}
    \bibliography{../biblio.bib}
    \newpage
    The source code used to generate this document is free software and released
    under version 3 of the GNU General Public License.
\end{document}
