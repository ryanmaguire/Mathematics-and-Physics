This thesis examines computational methods in knot theory. At first glance
this may seem to be a light-hearted endeavor since knots and links are very
intuitive objects. Indeed, many of the ideas behind the theory could be
adequately understood by a high school student, or even a junior high school
student with sufficient motivation. But as one dives deeper into the field they
discover many of the calculations to be performed are quite daunting. Three of
the four \textit{knot invariants} we are to discuss are known to fall into
the category of \textbf{NP-Hard} problems. To put it simply, being able to
compute any of these invariants for general knots in polynomial time
would lead one to proving $\textbf{P}=\textbf{NP}$,
\footnote{%
    Very briefly, this equality means that the ability to \textit{check} if a
    proposed solution is correct in polynomial time (\textbf{NP}) means it is
    possible to \textit{find} a solution in polynomial time (\textbf{P}). A
    simple example, 2 and 7 are the prime factorization of 14. You can
    \textit{check} this very quickly by multiplying 2 and 7. It is a much
    harder task to \textit{find} a prime factorization, in general.
}
earning the researcher
one million dollars from the Clay institute. This may, perhaps, lead to the
collapse of encryption as we know it, global banking would fail, and society
would fall into disarray.\footnote{%
    The author seriously doubts these statements, but many believe in them.
}
Thousands of other problems fall into the realm of
\textbf{NP-Hard} and \textbf{NP-Complete}, and finding quick solutions to any
of these would also prove $\textbf{P}=\textbf{NP}$. Since this has not been
done for any of these problems, many mathematicians and computer scientists
believe $\textbf{P}\ne\textbf{NP}$, meaning these problems do not have
efficient means of solving. For us this means our knot invariants will forever
be difficult to calculate. Failing to be dissuaded, we continue onward and
see what can be done.
\section{Algorithms}
    The primary result in this thesis is a new algorithm for the Jones
    polynomial. There are several that exist in the literature already with
    various trade-offs in time and space. This new one has excellent spatial
    properties.
    \begin{theorem}
        There is an algorithm with input a valid extended Gauss code on $N$
        crossings, with output the Jones polynomial of the (possibly virtual)
        knot described by the extended Gauss code, such that the best, worst,
        and average time complexity is identical and of
        $O(\textrm{poly}(N)\cdot{2}^{N})$, and with spatial requirement $O(N)$.
    \end{theorem}
    The straight-forward recursive algorithm discussed in chapter 3 has
    $O(\textrm{poly}(N)\cdot{2}^{N})$ requirements in both time and space.
    Simple improvements can be made on this that create best-case $O(N)$ in
    time and space, but this is for very specific knots. The worst-case scenario
    is still $O(\textrm{poly}(N)\cdot{2}^{N})$. An implementation of the
    modified-recursive algorithm is available in \cite{sage}.
    \par\hfill\par
    The Jones polynomial is generalized by the HOMFLY-PT polynomial, and the
    Kauffman skein algorithm is able to compute the Jones polynomial in
    $O(\textrm{poly}(N)\cdot{2}^{N})$ time, and by performing a depth-first
    search through the decision tree one can achieve $O(N)$ space
    \cite{Burton2018HOMFLFixedParameter}.
\section{Conjectures and Results}
